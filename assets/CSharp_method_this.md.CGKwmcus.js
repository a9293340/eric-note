import{_ as s,c as a,o as t,ae as e}from"./chunks/framework.Cwl8K4e2.js";const k=JSON.parse('{"title":"C# 中的 this 關鍵字","description":"","frontmatter":{},"headers":[],"relativePath":"CSharp/method/this.md","filePath":"CSharp/method/this.md"}'),h={name:"CSharp/method/this.md"};function l(n,i,d,o,c,r){return t(),a("div",null,i[0]||(i[0]=[e('<h1 id="c-中的-this-關鍵字" tabindex="-1">C# 中的 <code>this</code> 關鍵字 <a class="header-anchor" href="#c-中的-this-關鍵字" aria-label="Permalink to &quot;C# 中的 `this` 關鍵字&quot;">​</a></h1><h2 id="this-關鍵字的定義" tabindex="-1"><code>this</code> 關鍵字的定義 <a class="header-anchor" href="#this-關鍵字的定義" aria-label="Permalink to &quot;`this` 關鍵字的定義&quot;">​</a></h2><ul><li><code>this</code> 是 C# 中的一個預定義關鍵字，用於引用當前對象的實例。</li><li>每當調用實例方法時，必須有一個“當前對象”，這個對象在方法內部由 <code>this</code> 關鍵字表示。</li></ul><h2 id="this-關鍵字的使用" tabindex="-1"><code>this</code> 關鍵字的使用 <a class="header-anchor" href="#this-關鍵字的使用" aria-label="Permalink to &quot;`this` 關鍵字的使用&quot;">​</a></h2><ul><li><code>this</code> 只適用於實例方法（非靜態方法），不適用於靜態方法。</li><li>當通過某個對象調用方法時，<code>this</code> 會指向該對象。例如： <ul><li>如果通過 <code>object1</code> 調用方法，<code>this</code> 會指向 <code>object1</code>。</li><li>如果通過 <code>object2</code> 調用同一方法，<code>this</code> 會指向 <code>object2</code>。</li></ul></li></ul><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> productID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SetProductID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> productID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.productID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> productID; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 this 來區分字段和參數</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetProductID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.productID; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 this 來獲取字段的值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="this-關鍵字的特性" tabindex="-1"><code>this</code> 關鍵字的特性 <a class="header-anchor" href="#this-關鍵字的特性" aria-label="Permalink to &quot;`this` 關鍵字的特性&quot;">​</a></h2><ul><li>當方法的參數名稱與字段名稱相同時，必須使用 <code>this</code> 來明確引用字段。</li><li>如果參數名稱與字段名稱不同，則 <code>this</code> 是可選的。</li></ul><h2 id="this-關鍵字的作用" tabindex="-1"><code>this</code> 關鍵字的作用 <a class="header-anchor" href="#this-關鍵字的作用" aria-label="Permalink to &quot;`this` 關鍵字的作用&quot;">​</a></h2><ul><li><code>this</code> 使得代碼更具可讀性，特別是在參數和字段名稱相同的情況下。</li><li>它幫助開發者清楚地知道正在訪問的是字段還是參數。</li></ul><h2 id="this-關鍵字的限制" tabindex="-1"><code>this</code> 關鍵字的限制 <a class="header-anchor" href="#this-關鍵字的限制" aria-label="Permalink to &quot;`this` 關鍵字的限制&quot;">​</a></h2><ul><li><code>this</code> 不能在靜態方法中使用，因為靜態方法不依賴於任何特定的對象實例。</li></ul><h2 id="總結" tabindex="-1">總結 <a class="header-anchor" href="#總結" aria-label="Permalink to &quot;總結&quot;">​</a></h2><ul><li><code>this</code> 關鍵字是 C# 中用來引用當前對象的工具，主要用於實例方法中。</li><li>它有助於區分字段和參數，並提高代碼的可讀性。</li></ul><h2 id="this-在-javascript-和-net-中的差異" tabindex="-1"><code>this</code> 在 JavaScript 和 .NET 中的差異 <a class="header-anchor" href="#this-在-javascript-和-net-中的差異" aria-label="Permalink to &quot;`this` 在 JavaScript 和 .NET 中的差異&quot;">​</a></h2><h3 id="c-中的-this" tabindex="-1">C# 中的 <code>this</code> <a class="header-anchor" href="#c-中的-this" aria-label="Permalink to &quot;C# 中的 `this`&quot;">​</a></h3><ul><li>在 C# 中，<code>this</code> 代表當前對象的實例，並且只能在實例方法中使用。</li><li><code>this</code> 主要用於區分同名的參數和字段。</li></ul><h3 id="javascript-中的-this" tabindex="-1">JavaScript 中的 <code>this</code> <a class="header-anchor" href="#javascript-中的-this" aria-label="Permalink to &quot;JavaScript 中的 `this`&quot;">​</a></h3><ul><li>在 JavaScript 中，<code>this</code> 的值取決於函數的調用方式。</li><li>在全局上下文中，<code>this</code> 代表全局對象（在瀏覽器中是 <code>window</code>）。</li><li>在對象方法中，<code>this</code> 代表調用該方法的對象。</li><li>在事件處理器中，<code>this</code> 代表觸發事件的元素。</li></ul><h3 id="總結-1" tabindex="-1">總結 <a class="header-anchor" href="#總結-1" aria-label="Permalink to &quot;總結&quot;">​</a></h3><ul><li>C# 中的 <code>this</code> 是一個明確的關鍵字，始終指向當前對象，而 JavaScript 中的 <code>this</code> 則更具動態性，取決於上下文。</li></ul>',22)]))}const u=s(h,[["render",l]]);export{k as __pageData,u as default};
