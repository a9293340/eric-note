import{_ as i,c as s,o as l,ae as e}from"./chunks/framework.TiKqN8Et.js";const c=JSON.parse('{"title":"C# 中的方法重載（Method Overloading）","description":"","frontmatter":{},"headers":[],"relativePath":"CSharp/method/method_overload.md","filePath":"CSharp/method/method_overload.md"}'),t={name:"CSharp/method/method_overload.md"};function h(n,a,r,d,o,k){return l(),s("div",null,a[0]||(a[0]=[e(`<h1 id="c-中的方法重載-method-overloading" tabindex="-1">C# 中的方法重載（Method Overloading） <a class="header-anchor" href="#c-中的方法重載-method-overloading" aria-label="Permalink to &quot;C# 中的方法重載（Method Overloading）&quot;">​</a></h1><h2 id="什麼是方法重載" tabindex="-1">什麼是方法重載 <a class="header-anchor" href="#什麼是方法重載" aria-label="Permalink to &quot;什麼是方法重載&quot;">​</a></h2><ul><li>方法重載是指在同一個類中定義多個同名的方法，但使用不同的參數集。</li><li>這使得開發者可以根據需要選擇不同的參數來調用相同名稱的方法。</li></ul><h2 id="方法重載的特性" tabindex="-1">方法重載的特性 <a class="header-anchor" href="#方法重載的特性" aria-label="Permalink to &quot;方法重載的特性&quot;">​</a></h2><ul><li><strong>相同名稱</strong>：所有重載的方法必須具有相同的名稱。</li><li><strong>不同參數</strong>：重載的方法必須具有不同的參數類型、數量或順序。</li><li><strong>參數名稱無關緊要</strong>：參數的名稱不影響重載，只有參數的類型和數量重要。</li></ul><h2 id="使用場景" tabindex="-1">使用場景 <a class="header-anchor" href="#使用場景" aria-label="Permalink to &quot;使用場景&quot;">​</a></h2><ul><li>當需要根據不同的輸入類型或數量執行相同的邏輯時，使用方法重載可以提高代碼的靈活性和可讀性。</li></ul><h2 id="範例-計算稅金" tabindex="-1">範例：計算稅金 <a class="header-anchor" href="#範例-計算稅金" aria-label="Permalink to &quot;範例：計算稅金&quot;">​</a></h2><p>假設在 <code>Product</code> 類中，我們有一個名為 <code>CalculateTax</code> 的方法，根據成本計算稅金。</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CalculateTax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 稅率為 5%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CalculateTax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> profit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> profit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根據成本和利潤計算稅金</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="說明" tabindex="-1">說明 <a class="header-anchor" href="#說明" aria-label="Permalink to &quot;說明&quot;">​</a></h3><ul><li>第一個 <code>CalculateTax</code> 方法只接受一個參數 <code>cost</code>，計算稅金。</li><li>第二個 <code>CalculateTax</code> 方法接受兩個參數 <code>cost</code> 和 <code>profit</code>，計算稅金。</li><li>根據提供的參數數量，調用不同的重載方法。</li></ul><h2 id="方法重載的規則" tabindex="-1">方法重載的規則 <a class="header-anchor" href="#方法重載的規則" aria-label="Permalink to &quot;方法重載的規則&quot;">​</a></h2><ul><li>不能在同一個類中定義兩個具有相同名稱和相同參數類型的方法。</li><li>例如，不能定義 <code>CalculateTax(int x)</code> 和 <code>CalculateTax(int y)</code>，因為它們的參數類型相同。</li></ul><h2 id="實際應用" tabindex="-1">實際應用 <a class="header-anchor" href="#實際應用" aria-label="Permalink to &quot;實際應用&quot;">​</a></h2><ul><li>在實際項目中，當需要根據不同的參數組合執行相同的邏輯時，方法重載是一個非常有用的特性。</li><li>例如，開發者可以根據傳遞的參數數量選擇調用不同的實現。</li></ul><h2 id="結論" tabindex="-1">結論 <a class="header-anchor" href="#結論" aria-label="Permalink to &quot;結論&quot;">​</a></h2><ul><li>方法重載允許在同一個類中定義多個同名方法，根據不同的參數集執行不同的邏輯。</li><li>這提高了代碼的靈活性和可讀性，並使得開發者能夠根據需要選擇合適的調用方式。</li></ul>`,18)]))}const u=i(t,[["render",h]]);export{c as __pageData,u as default};
